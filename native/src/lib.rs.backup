#[cfg(test)]
#[cfg(test)]
mod tests {
    use super::types::*;
    use std::fs;
    use std::path::Path;
    use tempfile::TempDir;

    #[test]
    fn test_lsp_position_creation() {
        let pos = LspPosition { line: 5, character: 10 };
        assert_eq!(pos.line, 5);
        assert_eq!(pos.character, 10);
    }

    #[test]
    fn test_lsp_range_creation() {
        let start = LspPosition { line: 1, character: 0 };
        let end = LspPosition { line: 1, character: 10 };
        let range = LspRange { start, end };

        assert_eq!(range.start.line, 1);
        assert_eq!(range.start.character, 0);
        assert_eq!(range.end.line, 1);
        assert_eq!(range.end.character, 10);
    }

    #[test]
    fn test_git_status_type_enum() {
        let modified = GitStatusType::Modified;
        let added = GitStatusType::Added;
        let deleted = GitStatusType::Deleted;
        let untracked = GitStatusType::Untracked;

        // Just test that we can create them
        assert!(matches!(modified, GitStatusType::Modified));
        assert!(matches!(added, GitStatusType::Added));
        assert!(matches!(deleted, GitStatusType::Deleted));
        assert!(matches!(untracked, GitStatusType::Untracked));
    }

    #[tokio::test]
    async fn test_git_status() {
        let temp_dir = TempDir::new().unwrap();
        let repo_path = temp_dir.path().to_string_lossy().to_string();

        // Initialize a git repo
        let _ = std::process::Command::new("git")
            .args(&["init"])
            .current_dir(&repo_path)
            .output()
            .unwrap();

        // Create a test file
        let test_file = Path::new(&repo_path).join("test.txt");
        fs::write(&test_file, "Hello, World!").unwrap();

        // Stage the file
        let _ = std::process::Command::new("git")
            .args(&["add", "test.txt"])
            .current_dir(&repo_path)
            .output()
            .unwrap();

        // Test git status
        let result: Result<Vec<GitStatusEntry>, _> = super::git::git_status(repo_path.clone()).await;
        assert!(result.is_ok());

        let status = result.unwrap();
        assert!(!status.is_empty());

        // Should find the staged file
        let staged_file = status.iter().find(|s| s.path == "test.txt");
        assert!(staged_file.is_some());
    }

    #[test]
    fn test_lsp_range_creation() {
        let start = LspPosition { line: 1, character: 0 };
        let end = LspPosition { line: 1, character: 10 };
        let range = LspRange { start, end };

        assert_eq!(range.start.line, 1);
        assert_eq!(range.start.character, 0);
        assert_eq!(range.end.line, 1);
        assert_eq!(range.end.character, 10);
    }

    #[test]
    fn test_git_status_type_enum() {
        let modified = GitStatusType::Modified;
        let added = GitStatusType::Added;
        let deleted = GitStatusType::Deleted;
        let untracked = GitStatusType::Untracked;

        // Just test that we can create them
        assert!(matches!(modified, GitStatusType::Modified));
        assert!(matches!(added, GitStatusType::Added));
        assert!(matches!(deleted, GitStatusType::Deleted));
        assert!(matches!(untracked, GitStatusType::Untracked));
    }

    #[tokio::test]
    async fn test_git_status() {
        let temp_dir = TempDir::new().unwrap();
        let repo_path = temp_dir.path().to_string_lossy().to_string();

        // Initialize a git repo
        let _ = std::process::Command::new("git")
            .args(&["init"])
            .current_dir(&repo_path)
            .output()
            .unwrap();

        // Create a test file
        let test_file = Path::new(&repo_path).join("test.txt");
        fs::write(&test_file, "Hello, World!").unwrap();

        // Stage the file
        let _ = std::process::Command::new("git")
            .args(&["add", "test.txt"])
            .current_dir(&repo_path)
            .output()
            .unwrap();

        // Test git status
        let result: Result<Vec<GitStatusEntry>, _> = super::git::git_status(repo_path.clone()).await;
        assert!(result.is_ok());

        let status = result.unwrap();
        assert!(!status.is_empty());

        // Should find the staged file
        let staged_file = status.iter().find(|s| s.path == "test.txt");
        assert!(staged_file.is_some());
    }
}
